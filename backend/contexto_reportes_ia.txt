================================================================================
Archivo: reportes/models.py
================================================================================

# reportes/models.py
from django.db import models
from django.conf import settings


class PromptLog(models.Model):
    """
    Log de prompts usados en el módulo de reportes.

    - predicted_intent / confidence: salida opcional del modelo IA (si existe).
    - resolved_intent: intención final que realmente se ejecutó.
    - spec_json: spec completa que se usó para construir el queryset.
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="prompt_logs",
    )
    prompt_text = models.TextField()
    predicted_intent = models.CharField(max_length=50, null=True, blank=True)
    confidence = models.FloatField(null=True, blank=True)
    resolved_intent = models.CharField(max_length=50)  # intención final
    spec_json = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    # opcional: etiqueta humana (después de revisión manual)
    human_label = models.CharField(max_length=50, null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["created_at"]),
            models.Index(fields=["predicted_intent"]),
            models.Index(fields=["resolved_intent"]),
        ]
        ordering = ["-created_at"]

    def __str__(self):
        return f"[{self.created_at:%Y-%m-%d %H:%M}] {self.prompt_text[:60]}"


================================================================================
Archivo: reportes/serializers.py
================================================================================

*** ERROR: Archivo no encontrado en la ruta: reportes/serializers.py ***

================================================================================
Archivo: reportes/admin.py
================================================================================

from django.contrib import admin

# Register your models here.


================================================================================
Archivo: reportes/management/commands/export_prompts.py
================================================================================

# reportes/management/commands/export_prompts.py
from django.core.management.base import BaseCommand
from reportes.models import PromptLog
import csv, os
from django.conf import settings

class Command(BaseCommand):
    help = "Exporta prompts con baja confianza (o sin predicción) para rotular."

    def add_arguments(self, parser):
        parser.add_argument("--min_prob", type=float, default=0.55, help="Umbral de confianza máximo para exportar")
        parser.add_argument("--limit", type=int, default=200, help="Máximo de filas a exportar")

    def handle(self, *args, **opts):
        qs = PromptLog.objects.order_by("-created_at")
        qs = qs.filter(confidence__isnull=True) | qs.filter(confidence__lte=opts["min_prob"])
        qs = qs.order_by("-created_at")[:opts["limit"]]

        out_dir = os.path.join(settings.BASE_DIR, "ia")
        os.makedirs(out_dir, exist_ok=True)
        out_path = os.path.join(out_dir, "to_label.csv")

        with open(out_path, "w", encoding="utf-8", newline="") as f:
            w = csv.writer(f)
            # columnas: texto, etiqueta_sugerida, confianza, etiqueta_humana (vacía)
            w.writerow(["texto", "predicha", "confianza", "etiqueta_humana"])
            for p in qs:
                w.writerow([p.prompt_text, p.predicted_intent or "", p.confidence or "", ""])

        self.stdout.write(self.style.SUCCESS(f"Exportado a {out_path}. Rellena 'etiqueta_humana' y agrega filas a ia/training_data.csv"))


================================================================================
Archivo: reportes/management/commands/train_models.py
================================================================================

# reportes/management/commands/train_models.py
from django.core.management.base import BaseCommand
import ia.train_intents as ti
try:
    import ia.train_predictions as tp
    HAS_PRED = True
except Exception:
    HAS_PRED = False

class Command(BaseCommand):
    help = "Reentrena IA de intenciones y, si existe, el modelo de predicciones."

    def handle(self, *args, **options):
        self.stdout.write(self.style.MIGRATE_HEADING("Entrenando modelo de intenciones..."))
        res = ti.train_model()
        self.stdout.write(self.style.SUCCESS(f"✔ CV Acc: {res.cv_accuracy:.3f}"))  # indicador estable

        if HAS_PRED:
            self.stdout.write(self.style.MIGRATE_HEADING("Entrenando modelo de predicciones..."))
            try:
                tp.train_model()
                self.stdout.write(self.style.SUCCESS("✔ Predicciones: OK"))
            except Exception as e:
                self.stdout.write(self.style.ERROR(f"❌ Predicciones: {e}"))


================================================================================
Archivo: reportes/logger.pyreportes/views.py
================================================================================

*** ERROR: Archivo no encontrado en la ruta: reportes/logger.pyreportes/views.py ***

================================================================================
Archivo: reportes/parser.py
================================================================================

# reportes/parser.py
import os
import re
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from django.conf import settings

try:
    import joblib
except Exception:
    joblib = None

# ------------------------------
# Utiles de fecha (simple)
# ------------------------------
SPANISH_MONTHS = {
    "enero": 1, "febrero": 2, "marzo": 3, "abril": 4, "mayo": 5, "junio": 6,
    "julio": 7, "agosto": 8, "septiembre": 9, "setiembre": 9, "octubre": 10,
    "noviembre": 11, "diciembre": 12,
}

def _ultimo_dia_mes(mes: int, year: int) -> int:
    if mes in (1, 3, 5, 7, 8, 10, 12):
        return 31
    if mes == 2:
        # suficiente para reportes (no necesitamos calendario exacto de bisiesto)
        return 29
    return 30

def _norm_fecha(s: str) -> str:
    """
    Normaliza "DD/MM/YYYY" a "YYYY-MM-DD".
    Si ya está en formato ISO, lo deja igual.
    """
    s = s.strip()
    if "/" in s and len(s.split("/")) == 3:
        d, m, y = s.split("/")
        d = d.zfill(2)
        m = m.zfill(2)
        return f"{y}-{m}-{d}"
    return s  # ya está YYYY-MM-DD

# ------------------------------
# Cargador del modelo IA (opcional)
# ------------------------------
_MODEL = None

def _load_model():
    """Carga ia/prompt_intent_model.joblib si existe (silencioso)."""
    global _MODEL
    if _MODEL is not None:
        return _MODEL
    if not joblib:
        return None
    path = os.path.join(settings.BASE_DIR, "ia", "prompt_intent_model.joblib")
    if os.path.exists(path):
        try:
            _MODEL = joblib.load(path)
        except Exception:
            _MODEL = None
    return _MODEL

# ------------------------------
# Parser principal
# ------------------------------
def parse_prompt(prompt: str) -> Dict[str, Any]:
    """
    Devuelve un dict con:
     - intent: ventas | stock | stock_bajo | precios | top_productos | sin_movimiento | agregar_carrito
     - group_by: 'producto' | 'cliente' | 'categoria'
     - start_date, end_date (YYYY-MM-DD o None)
     - format: pantalla | pdf | excel
     - limit, threshold
     - categoria, marca, contiene, cliente
     - order_by, order_dir (para top/menos vendidos)
    """
    p = (prompt or "").lower().strip()

    out: Dict[str, Any] = {
        "intent": "ventas",
        "group_by": "producto",
        "start_date": None,
        "end_date": None,
        "format": "pantalla",
        "limit": None,
        "threshold": None,
        "categoria": None,
        "marca": None,
        "contiene": None,
        "cliente": None,
        "order_by": None,
        "order_dir": None,
    }

    # ---- 0) INTENCIÓN ESPECIAL: agregar al carrito ----
    # ejemplos: "agrega 2 licuadoras al carrito", "quiero 3 mouse gamer a la compra"
    if re.search(r"\b(agrega|añade|quiero|pon|mete)\b", p) and re.search(r"\b(carrito|compra|pedido)\b", p):
        out["intent"] = "agregar_carrito"
        m_prod = re.search(
            r"(?:agrega|añade|quiero|pon|mete)\s+(?:(\d+)\s+)?(.+?)\s+(?:al|a la)\s+(?:carrito|compra|pedido)",
            p
        )
        if m_prod:
            out["limit"] = int(m_prod.group(1) or 1)         # cantidad
            out["contiene"] = m_prod.group(2).strip()        # nombre del producto
        return out  # retornamos de inmediato

    # ---- 1) IA: clasifica intención si hay modelo entrenado ----
    model = _load_model()
    if model is not None:
        try:
            proba = model.predict_proba([p])[0]
            labels = model.classes_
            top_i = int(proba.argmax())
            if proba[top_i] >= 0.60:  # umbral de confianza
                out["intent"] = labels[top_i]
        except Exception:
            pass

    # ---- 2) Reglas complementarias / override ----
    # "compras" se considera ventas (sin cambiar el intent si IA ya puso otro)
    if re.search(r"\b(compra|compras|orden(es)?)\b", p):
        out["intent"] = "ventas"

    if re.search(r"\b(precio|precios|lista de precios)\b", p):
        out["intent"] = "precios"

    elif re.search(r"\b(stock|inventario|existenc)\b", p):
        out["intent"] = "stock"
        if re.search(r"\b(poco|bajo|menor|reponer|renovar)\b.*\bstock\b", p) or \
           re.search(r"\bstock\s+(bajo|menor|crítico|critico)\b", p):
            out["intent"] = "stock_bajo"

    elif re.search(r"(m[aá]s\s+vendid|top\s*\d+|ranking|estrella|populares)", p):
        out["intent"] = "top_productos"

    elif re.search(r"(sin venta|no se vendi[oó]|sin movimiento|no vendidos)", p):
        out["intent"] = "sin_movimiento"
    
    elif re.search(r"(menos\s+vendid)", p):
        # Top invertido: queremos los menos vendidos
        out["intent"] = "top_productos"
        out["order_by"] = "unidades"
        out["order_dir"] = "asc"

    # ---- 3) Fechas ----
    # formato explícito "del DD/MM/YYYY al DD/MM/YYYY" (o YYYY-MM-DD)
    r = re.search(
        r"del\s+(\d{2}/\d{2}/\d{4}|\d{4}-\d{2}-\d{2})\s+al\s+(\d{2}/\d{2}/\d{4}|\d{4}-\d{2}-\d{2})",
        p
    )
    if r:
        out["start_date"] = _norm_fecha(r.group(1))
        out["end_date"] = _norm_fecha(r.group(2))
    else:
        # fechas sueltas
        fechas = re.findall(r"(\d{2}/\d{2}/\d{4}|\d{4}-\d{2}-\d{2})", p)
        if len(fechas) >= 1:
            out["start_date"] = _norm_fecha(fechas[0])
        if len(fechas) >= 2:
            out["end_date"] = _norm_fecha(fechas[1])

        # "mes de septiembre", "mensual de octubre"
        if not out["start_date"] and ("mes de " in p or "mensual" in p):
            m = re.search(r"mes de ([a-zñ]+)", p)
            if m:
                month_name = m.group(1)
                mes = SPANISH_MONTHS.get(month_name)
                if mes:
                    year = datetime.now().year
                    out["start_date"] = f"{year}-{mes:02d}-01"
                    out["end_date"] = f"{year}-{mes:02d}-{_ultimo_dia_mes(mes, year):02d}"

        # "este mes"
        if "este mes" in p and not out["start_date"]:
            today = datetime.now().date()
            out["start_date"] = today.replace(day=1).strftime("%Y-%m-%d")
            out["end_date"] = today.strftime("%Y-%m-%d")

        # "hoy"
        if "hoy" in p and not out["start_date"]:
            today = datetime.now().date().strftime("%Y-%m-%d")
            out["start_date"] = today
            out["end_date"] = today

        # "ayer"
        if "ayer" in p and not out["start_date"]:
            d = datetime.now().date() - timedelta(days=1)
            out["start_date"] = d.strftime("%Y-%m-%d")
            out["end_date"] = d.strftime("%Y-%m-%d")

        # "último mes", "mes pasado" (dejamos que el builder use fallback 30 días si no se setea)
        if ("último mes" in p or "ultimo mes" in p or "mes pasado" in p) and not out["start_date"]:
            # sin setear: el service / builder aplica fallback (últimos 30 días)
            pass

    # ---- 4) Formato ----
    if "pdf" in p:
        out["format"] = "pdf"
    elif "excel" in p or "xlsx" in p:
        out["format"] = "excel"
    else:
        out["format"] = "pantalla"

    # ---- 5) Limit (top) ----
    mtop = re.search(r"\btop\s+(\d{1,3})\b", p)
    if mtop:
        out["limit"] = int(mtop.group(1))
    if out["limit"] is None:
        mcount = re.search(r"\b(?:los\s+)?(\d{1,3})\s+(?:productos?|items?)\b", p)
        if mcount:
            out["limit"] = int(mcount.group(1))

    # ---- 6) Threshold (para stock bajo) ----
    mth = re.search(r"(?:menor(?:\s*a)?|<)\s*(\d{1,6})", p)
    if mth:
        out["threshold"] = int(
            mth.group(2) if mth.lastindex and mth.group(2) else mth.group(1)
        )

    # ---- 7) Filtros simples (categoría, marca, nombre de producto) ----
    mc = re.search(r"categor[ií]a\s+([a-z0-9áéíóúñ \-_/]+)", p)
    if mc:
        out["categoria"] = mc.group(1).strip()

    mm = re.search(r"marca\s+([a-z0-9áéíóúñ \-_/]+)", p)
    if mm:
        out["marca"] = mm.group(1).strip()

    mn = re.search(r"(?:que\s+contenga|contiene|con\s+nombre)\s+([a-z0-9áéíóúñ \-_/]+)", p)
    if mn:
        out["contiene"] = mn.group(1).strip()

    # ---- 8) Filtro por cliente (nombre / doc) ----
    # ejemplos:
    #   "del cliente juan perez"
    #   "para el cliente carlos"
    #   "ventas del cliente maria en este mes"
    mcli = re.search(r"(?:del|de|para(?:\s+el)?)\s+cliente\s+([a-z0-9áéíóúñ ]{2,})", p)
    if mcli:
        raw = mcli.group(1).strip()
        # cortamos en palabras típicas que marcan el fin del nombre
        raw = re.split(r"\s+(?:en|del|de|desde|hasta|al|por|y|con|que|mes|año|anio)\b", raw)[0].strip()
        if raw:
            out["cliente"] = raw

    # ---- 9) Orden (legacy: por si lo necesitas desde services) ----
    if re.search(r"(menor a mayor|ascendente|asc\b)", p):
        out["order_dir"] = "asc"
    elif re.search(r"(mayor a menor|descendente|desc\b)", p):
        out["order_dir"] = "desc"

    if re.search(r"ordenad[oa]s?\s+por\s+stock", p):
        out["order_by"] = "stock"

    # ---- 10) Agrupación (group_by) ----
    # "por cliente", "por categoría", "por producto"
    if re.search(r"por\s+cliente", p):
        out["group_by"] = "cliente"
    elif re.search(r"por\s+categori", p):
        out["group_by"] = "categoria"
    elif re.search(r"por\s+producto", p):
        out["group_by"] = "producto"
    # (default ya es "producto")

    return out


================================================================================
Archivo: reportes/runner.py
================================================================================

# reportes/runner.py
from typing import Tuple, List, Dict, Any, Optional

from .parser import parse_prompt
from .services import (
    consultar_ventas,
    consultar_top_productos,
    consultar_sin_movimiento,
    consultar_stock,
    consultar_stock_bajo,
    consultar_precios,
)
from .logger import log_prompt

# Si quieres seguir usando query_builder como fallback:
try:
    from .query_builder import build_queryset
except Exception:   # pragma: no cover
    build_queryset = None


def _safe_log(user, prompt: str, spec: Dict[str, Any]) -> None:
    """
    Loguea el prompt sin romper el flujo si hay errores.
    """
    try:
        # De momento no tenemos "predicted" separado del parser,
        # así que lo dejamos en None.
        log_prompt(user, prompt, None, spec.get("intent", "ventas"), spec)
    except Exception:
        pass


def run_prompt(prompt: str, user=None, parse_only: bool = False):
    """
    Interpreta un prompt en lenguaje natural y ejecuta el reporte correspondiente.

    Retorna:
      - Si parse_only=True → solo el spec (dict).
      - Si parse_only=False → (spec, headers, rows, warnings)
    """
    spec = parse_prompt(prompt or "")
    _safe_log(user, prompt, spec)

    if parse_only:
        return spec

    intent = spec.get("intent", "ventas")
    headers: List[str] = []
    rows: List[List[Any]] = []
    warnings: List[str] = []

    start_date = spec.get("start_date")
    end_date = spec.get("end_date")
    group_by = spec.get("group_by") or "producto"
    categoria = spec.get("categoria")
    marca = spec.get("marca")
    contiene = spec.get("contiene")
    cliente = spec.get("cliente")
    limit = spec.get("limit")
    threshold = spec.get("threshold")

    # ----------------------------------------
    # 1) Intención: ventas / productos comprados
    # ----------------------------------------
    if intent == "ventas":
        headers, rows = consultar_ventas(
            start_date,
            end_date,
            group_by,
            cliente=cliente,
            contiene=contiene,
        )

    # ----------------------------------------
    # 2) Intención: ranking de productos
    # ----------------------------------------
    elif intent == "top_productos":
        headers, rows = consultar_top_productos(
            start_date,
            end_date,
            limit,
            categoria=categoria,
        )
        if spec.get("order_dir") == "asc":
            # para "menos vendidos": invertimos el orden
            rows = list(reversed(rows))

    # ----------------------------------------
    # 3) Intención: productos sin movimiento
    # ----------------------------------------
    elif intent == "sin_movimiento":
        headers, rows = consultar_sin_movimiento(
            start_date,
            end_date,
            categoria=categoria,
        )

    # ----------------------------------------
    # 4) Intención: stock / stock bajo / precios
    # ----------------------------------------
    elif intent == "stock":
        headers, rows = consultar_stock(
            categoria=categoria,
            marca=marca,
            contiene=contiene,
        )

    elif intent == "stock_bajo":
        headers, rows = consultar_stock_bajo(
            threshold=threshold,
            categoria=categoria,
            limit=limit,
        )

    elif intent == "precios":
        headers, rows = consultar_precios(
            categoria=categoria,
            marca=marca,
            contiene=contiene,
        )

    # ----------------------------------------
    # 5) Fallback / casos no contemplados
    # ----------------------------------------
    else:
        if build_queryset is not None:
            try:
                # build_queryset puede aceptar dict tal cual,
                # o puedes adaptarlo aquí si necesita otra estructura.
                headers, rows = build_queryset(spec)
            except Exception as e:
                warnings.append(
                    f"No supe cómo construir un reporte específico para la intención '{intent}'. "
                    f"Detalle: {e}"
                )
        else:
            warnings.append(
                f"No existe implementación para la intención '{intent}'. "
                "Devuelvo un resultado vacío."
            )

    return spec, headers, rows, warnings


================================================================================
Archivo: reportes/services.py
================================================================================

# reportes/services.py
from io import BytesIO
from typing import Tuple, Dict, Any, List, Optional

from datetime import timedelta
from django.utils import timezone
from django.db.models import Sum, F, Avg, Q
from django.db.models.functions import TruncDay, TruncMonth

from ventas.models import Venta, ItemVenta
from clientes.models import Cliente
from catalogo.models import Producto

# Excel
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, numbers, PatternFill, Border, Side
from openpyxl.utils import get_column_letter

# PDF
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.lib.units import cm
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer


# =========================
# Consultas de ventas
# =========================

def consultar_ventas(
    start_date: Optional[str],
    end_date: Optional[str],
    group_by: str,
    cliente: Optional[str] = None,
    contiene: Optional[str] = None,
) -> Tuple[List[str], List[List]]:
    """
    Reportes de ventas.

    - group_by = 'producto'  → productos vendidos
    - group_by = 'cliente'   → ventas por cliente
    - group_by = 'categoria' → ventas por categoría
    """
    qs = ItemVenta.objects.select_related(
        "venta", "producto", "venta__cliente", "producto__categoria"
    )

    if start_date:
        qs = qs.filter(venta__creado_en__date__gte=start_date)
    if end_date:
        qs = qs.filter(venta__creado_en__date__lte=end_date)

    qs = qs.filter(venta__estado__in=["pagada"])

    if cliente:
        qs = qs.filter(
            Q(venta__cliente__nombre__icontains=cliente)
            | Q(venta__cliente__apellido__icontains=cliente)
            | Q(venta__cliente__ci_nit__icontains=cliente)
        )

    if contiene:
        qs = qs.filter(producto__nombre__icontains=contiene)

    rows: List[List] = []
    headers: List[str] = []

    if group_by == "producto":
        agg = (
            qs.values(nombre=F("producto__nombre"))
            .annotate(
                cantidad=Sum("cantidad"),
                monto=Sum(F("subtotal")),
            )
            .order_by("-monto", "-cantidad", "nombre")
        )
        headers = ["Producto", "Cantidad total", "Monto total"]
        rows = [
            [r["nombre"], int(r["cantidad"] or 0), float(r["monto"] or 0.0)]
            for r in agg
        ]

    elif group_by == "cliente":
        agg = (
            qs.values(
                cliente=F("venta__cliente__nombre"),
                doc=F("venta__cliente__ci_nit"),
            )
            .annotate(
                cantidad=Sum("cantidad"),
                monto=Sum(F("subtotal")),
            )
            .order_by("-monto", "-cantidad", "cliente")
        )
        headers = ["Cliente", "Documento", "Cantidad total", "Monto total"]
        rows = [
            [
                r["cliente"] or "SIN NOMBRE",
                r["doc"] or "",
                int(r["cantidad"] or 0),
                float(r["monto"] or 0.0),
            ]
            for r in agg
        ]

    elif group_by == "categoria":
        agg = (
            qs.values(cat=F("producto__categoria__nombre"))
            .annotate(
                cantidad=Sum("cantidad"),
                monto=Sum(F("subtotal")),
            )
            .order_by("-monto", "-cantidad", "cat")
        )
        headers = ["Categoría", "Cantidad total", "Monto total"]
        rows = [
            [
                r["cat"] or "SIN CATEGORÍA",
                int(r["cantidad"] or 0),
                float(r["monto"] or 0.0),
            ]
            for r in agg
        ]
    else:
        agg = (
            qs.values(
                folio=F("venta__folio"),
                fecha=F("venta__creado_en__date"),
                cliente=F("venta__cliente__nombre"),
            )
            .annotate(
                cantidad=Sum("cantidad"),
                monto=Sum(F("subtotal")),
            )
            .order_by("-fecha", "-monto")
        )
        headers = ["Folio", "Fecha", "Cliente", "Cantidad total", "Monto total"]
        rows = [
            [
                r["folio"],
                r["fecha"].strftime("%Y-%m-%d") if r["fecha"] else "",
                r["cliente"] or "SIN NOMBRE",
                int(r["cantidad"] or 0),
                float(r["monto"] or 0.0),
            ]
            for r in agg
        ]

    return headers, rows


def consultar_top_productos(
    start_date: Optional[str],
    end_date: Optional[str],
    limit: Optional[int],
    categoria: Optional[str] = None,
) -> Tuple[List[str], List[List]]:
    """Ranking de productos más vendidos en un período."""
    qs = ItemVenta.objects.select_related("venta", "producto", "producto__categoria")
    if start_date:
        qs = qs.filter(venta__creado_en__date__gte=start_date)
    if end_date:
        qs = qs.filter(venta__creado_en__date__lte=end_date)
    qs = qs.filter(venta__estado__in=["pagada"])
    if categoria:
        qs = qs.filter(producto__categoria__nombre__icontains=categoria)

    agg = (
        qs.values(n=F("producto__nombre"))
        .annotate(cantidad=Sum("cantidad"), monto=Sum(F("subtotal")))
        .order_by("-cantidad", "-monto", "n")
    )
    if limit:
        agg = agg[:limit]

    headers = ["Producto", "Cantidad vendida", "Monto total"]
    rows = [
        [r["n"], int(r["cantidad"] or 0), float(r["monto"] or 0)] for r in agg
    ]
    return headers, rows


def consultar_sin_movimiento(
    start_date: Optional[str],
    end_date: Optional[str],
    categoria: Optional[str] = None,
) -> Tuple[List[str], List[List]]:
    """Productos que NO tuvieron ventas en el período."""
    vendibles = ItemVenta.objects.select_related("venta", "producto")
    if start_date:
        vendibles = vendibles.filter(venta__creado_en__date__gte=start_date)
    if end_date:
        vendibles = vendibles.filter(venta__creado_en__date__lte=end_date)
    vendibles = vendibles.values_list("producto_id", flat=True).distinct()

    qs = Producto.objects.exclude(id__in=vendibles).select_related("categoria")
    if categoria:
        qs = qs.filter(categoria__nombre__icontains=categoria)

    headers = ["Producto", "Categoría", "Stock", "Precio", "Observación"]
    rows = []
    for p in qs.order_by("nombre"):
        rows.append(
            [
                p.nombre,
                getattr(p.categoria, "nombre", "")
                if getattr(p, "categoria", None)
                else "",
                getattr(p, "stock", 0),
                float(getattr(p, "precio", 0.0)),
                "Sin ventas en el período",
            ]
        )
    return headers, rows


# =========================
# Stock / Precios
# =========================

def consultar_stock(
    categoria: Optional[str] = None,
    marca: Optional[str] = None,
    contiene: Optional[str] = None,
):
    qs = Producto.objects.select_related("categoria")
    if categoria:
        qs = qs.filter(categoria__nombre__icontains=categoria)
    if marca and hasattr(Producto, "marca"):
        qs = qs.filter(marca__nombre__icontains=marca)
    if contiene:
        qs = qs.filter(nombre__icontains=contiene)

    headers = ["Producto", "Categoría", "Stock", "Stock mínimo", "Precio"]
    rows = []
    for p in qs.order_by("nombre"):
        rows.append(
            [
                p.nombre,
                getattr(p.categoria, "nombre", "")
                if getattr(p, "categoria", None)
                else "",
                getattr(p, "stock", 0),
                getattr(p, "stock_minimo", 0),
                float(getattr(p, "precio", 0.0)),
            ]
        )
    return headers, rows


def consultar_stock_bajo(
    threshold: Optional[int] = None,
    categoria: Optional[str] = None,
    limit: Optional[int] = None,
):
    qs = Producto.objects.select_related("categoria")

    if categoria:
        qs = qs.filter(categoria__nombre__icontains=categoria)

    if threshold is not None:
        qs = qs.filter(stock__lt=threshold)
    elif hasattr(Producto, "stock_minimo"):
        qs = qs.filter(stock__lt=F("stock_minimo"))
    else:
        qs = qs.filter(stock__lt=10)

    qs = qs.order_by("stock", "nombre")
    if limit:
        qs = qs[:limit]

    headers = ["Producto", "Categoría", "Stock", "Stock mínimo", "Sugerencia"]
    rows = []
    for p in qs:
        minimo = getattr(p, "stock_minimo", None)
        sug = f"Reponer hasta {minimo}" if minimo else "Reponer"
        rows.append(
            [
                p.nombre,
                getattr(p.categoria, "nombre", "")
                if getattr(p, "categoria", None)
                else "",
                getattr(p, "stock", 0),
                minimo if minimo is not None else "-",
                sug,
            ]
        )
    return headers, rows


def consultar_precios(
    categoria: Optional[str] = None,
    marca: Optional[str] = None,
    contiene: Optional[str] = None,
):
    qs = Producto.objects.select_related("categoria")
    if categoria:
        qs = qs.filter(categoria__nombre__icontains=categoria)
    if marca and hasattr(Producto, "marca"):
        qs = qs.filter(marca__nombre__icontains=marca)
    if contiene:
        qs = qs.filter(nombre__icontains=contiene)

    headers = ["Producto", "Categoría", "Precio", "Stock"]
    rows = []
    for p in qs.order_by("nombre"):
        rows.append(
            [
                p.nombre,
                getattr(p.categoria, "nombre", "")
                if getattr(p, "categoria", None)
                else "",
                float(getattr(p, "precio", 0.0)),
                getattr(p, "stock", 0),
            ]
        )
    return headers, rows


# =========================
# Exportadores Excel / PDF
# =========================

def generar_excel(headers: List[str], rows: List[List]) -> bytes:
    wb = Workbook()
    ws = wb.active
    ws.title = "Reporte"

    ws.append(headers)
    header_fill = PatternFill(start_color="1E293B", end_color="1E293B", fill_type="solid")
    header_ink = Font(bold=True, color="FFFFFF")
    for col_idx, _ in enumerate(headers, start=1):
        cell = ws.cell(row=1, column=col_idx)
        cell.font = header_ink
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal="center", vertical="center")

    for r in rows:
        ws.append(r)

    ws.freeze_panes = "A2"

    if headers and "monto" in headers[-1].lower():
        for row_idx in range(2, ws.max_row + 1):
            c = ws.cell(row=row_idx, column=len(headers))
            try:
                float(c.value)
                c.number_format = numbers.FORMAT_CURRENCY_USD_SIMPLE
                c.alignment = Alignment(horizontal="right")
            except Exception:
                pass

    for idx, h in enumerate(headers, start=1):
        if "cantidad" in h.lower():
            for row_idx in range(2, ws.max_row + 1):
                ws.cell(row=row_idx, column=idx).alignment = Alignment(horizontal="center")

    thin = Side(style="thin", color="DDDDDD")
    border = Border(top=thin, left=thin, right=thin, bottom=thin)
    for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=len(headers)):
        for cell in row:
            cell.border = border

    for col_idx in range(1, len(headers) + 1):
        max_len = 0
        for row_idx in range(1, ws.max_row + 1):
            val = ws.cell(row=row_idx, column=col_idx).value
            if val is None:
                continue
            max_len = max(max_len, len(str(val)))
        ws.column_dimensions[get_column_letter(col_idx)].width = min(max(12, max_len + 2), 42)

    out = BytesIO()
    wb.save(out)
    return out.getvalue()


def generar_pdf(headers: List[str], rows: List[List], meta: Dict[str, Any]) -> bytes:
    buf = BytesIO()
    doc = SimpleDocTemplate(
        buf,
        pagesize=A4,
        leftMargin=2 * cm,
        rightMargin=2 * cm,
        topMargin=1.8 * cm,
        bottomMargin=1.8 * cm,
    )

    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        name="Title",
        parent=styles["Heading1"],
        fontName="Helvetica-Bold",
        fontSize=16,
        leading=20,
        textColor=colors.HexColor("#0f172a"),
        spaceAfter=10,
    )
    meta_style = ParagraphStyle(
        name="Meta",
        parent=styles["Normal"],
        fontName="Helvetica",
        fontSize=10,
        textColor=colors.HexColor("#64748b"),
        spaceAfter=8,
    )

    elems = []
    elems.append(Paragraph("Reporte", title_style))

    rango = f"Rango: {meta.get('start_date') or '-'} a {meta.get('end_date') or '-'}"
    detalles = []
    if meta.get("group_by"):
        detalles.append(f"Grupo: {meta.get('group_by')}")
    if meta.get("intent"):
        detalles.append(f"Intento: {meta.get('intent')}")
    if meta.get("metrics"):
        detalles.append(f"Métricas: {', '.join(meta.get('metrics'))}")
    sub = rango + (f" | {' | '.join(detalles)}" if detalles else "")
    elems.append(Paragraph(sub, meta_style))
    elems.append(Spacer(1, 6))

    data = []
    if headers:
        data.append(headers)
    data.extend(rows or [])

    table = Table(data, repeatRows=1)
    table.setStyle(
        TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#0f172a")),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
                ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("FONTSIZE", (0, 0), (-1, 0), 10),
                ("ALIGN", (0, 0), (-1, 0), "CENTER"),
                ("BOTTOMPADDING", (0, 0), (-1, 0), 8),
                ("FONTNAME", (0, 1), (-1, -1), "Helvetica"),
                ("FONTSIZE", (0, 1), (-1, -1), 9),
                ("GRID", (0, 0), (-1, -1), 0.5, colors.HexColor("#e5e7eb")),
                ("ROWBACKGROUNDS", (0, 1), (-1, -1),
                 [colors.white, colors.HexColor("#f8fafc")]),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
            ]
        )
    )

    if headers and any(k in headers[-1].lower() for k in ("monto", "total", "precio")):
        table.setStyle(TableStyle([("ALIGN", (-1, 1), (-1, -1), "RIGHT")]))

    elems.append(table)
    doc.build(elems)
    pdf = buf.getvalue()
    buf.close()
    return pdf


# =========================
# Datos para Dashboard
# =========================

def get_dashboard_data() -> Dict[str, Any]:
    now = timezone.now()
    today = now.date()
    start_of_month = today.replace(day=1)
    start_of_30_days = today - timedelta(days=30)

    ventas_pagadas = Venta.objects.filter(estado="pagada")

    ventas_hoy = (
        ventas_pagadas.filter(creado_en__date=today)
        .aggregate(total=Sum("total"))["total"]
        or 0
    )
    ventas_mes = (
        ventas_pagadas.filter(creado_en__gte=start_of_month)
        .aggregate(total=Sum("total"))["total"]
        or 0
    )
    ticket_promedio = (
        ventas_pagadas.filter(creado_en__gte=start_of_month)
        .aggregate(avg=Avg("total"))["avg"]
        or 0
    )
    nuevos_clientes_mes = Cliente.objects.filter(
        creado_en__gte=start_of_month
    ).count()

    ventas_diarias = (
        ventas_pagadas.filter(creado_en__gte=start_of_30_days)
        .annotate(dia=TruncDay("creado_en"))
        .values("dia")
        .annotate(total=Sum("total"))
        .order_by("dia")
    )

    ventas_por_categoria = (
        ventas_pagadas.filter(creado_en__gte=start_of_month)
        .values("items__producto__categoria__nombre")
        .annotate(total=Sum("items__subtotal"))
        .order_by("-total")
    )

    ultimas_ventas = ventas_pagadas.order_by("-creado_en")[:5].select_related("cliente")

    return {
        "kpis": {
            "ventas_hoy": f"{ventas_hoy:,.2f}",
            "ventas_mes_actual": f"{ventas_mes:,.2f}",
            "nuevos_clientes_mes": nuevos_clientes_mes,
            "ticket_promedio": f"{ticket_promedio:,.2f}",
        },
        "ventas_ultimos_30_dias": [
            {"fecha": item["dia"].strftime("%Y-%m-%d"), "total": float(item["total"])}
            for item in ventas_diarias
        ],
        "ventas_por_categoria": [
            {
                "categoria": item["items__producto__categoria__nombre"],
                "total": float(item["total"]),
            }
            for item in ventas_por_categoria
            if item["items__producto__categoria__nombre"]
        ],
        "ultimas_ventas": [
            {
                "id": v.id,
                "folio": v.folio,
                "cliente": v.cliente.nombre if v.cliente else "N/A",
                "total": f"{v.total:,.2f}",
                "fecha": v.creado_en.strftime("%Y-%m-%d %H:%M"),
            }
            for v in ultimas_ventas
        ],
    }


================================================================================
Archivo: reportes/urls.py
================================================================================

from django.urls import path
from .views import ReportePromptView, dashboard_data_view

urlpatterns = [
    path("prompt/", ReportePromptView.as_view(), name="reporte_prompt"),
    path("dashboard/", dashboard_data_view, name="dashboard_data"),
]


================================================================================
Archivo: reportes/catalog.pyreportes/dsl.pyreportes/intent_parser.pyreportes/queries_extra.pyreportes/query_builder.pyreportes/renderers.pyia/train_intents.py
================================================================================

*** ERROR: Archivo no encontrado en la ruta: reportes/catalog.pyreportes/dsl.pyreportes/intent_parser.pyreportes/queries_extra.pyreportes/query_builder.pyreportes/renderers.pyia/train_intents.py ***

================================================================================
Archivo: ia/train_predictions.py
================================================================================

# ia/train_predictions.py
import os
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import joblib
from datetime import timedelta

from django.conf import settings
from django.db import models
from ventas.models import Venta


def get_sales_data():
    """
    Obtiene los datos de ventas diarias de la base deatos y los prepara para el modelo.
    """
    # Obtenemos ventas pagadas, agrupadas por día
    sales = (
        Venta.objects.filter(estado="pagada")
        .values("creado_en__date")
        .annotate(total_ventas=models.Sum("total"))
        .order_by("creado_en__date")
    )

    if not sales:
        return pd.DataFrame()

    df = pd.DataFrame(list(sales))
    df = df.rename(columns={"creado_en__date": "fecha", "total_ventas": "ventas"})
    df["fecha"] = pd.to_datetime(df["fecha"])
    df = df.set_index("fecha")

    # Asegurarnos de que tenemos un rango de fechas continuo, rellenando días sin ventas con 0
    df = df.asfreq('D', fill_value=0)
    return df


def create_features(df):
    """
    Crea características (features) a partir de la fecha para el modelo.
    """
    df['dia_semana'] = df.index.dayofweek  # Lunes=0, Domingo=6
    df['dia_mes'] = df.index.day
    df['mes'] = df.index.month
    df['anio'] = df.index.year
    df['semana_anio'] = df.index.isocalendar().week.astype(int)
    return df


def train_model():
    """
    Función principal que carga datos, entrena el modelo y lo guarda.
    """
    print("Iniciando entrenamiento del modelo de predicción de ventas...")
    df = get_sales_data()

    # Si no hay datos, no podemos entrenar
    if df.shape[0] < 30:
        print("No hay suficientes datos históricos (< 30 días). No se entrenará el modelo.")
        return None

    df = create_features(df)

    FEATURES = ['dia_semana', 'dia_mes', 'mes', 'anio', 'semana_anio']
    TARGET = 'ventas'

    X = df[FEATURES]
    y = df[TARGET]

    # Dividimos los datos para una validación simple
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=False)

    # Modelo: RandomForestRegressor
    model = RandomForestRegressor(n_estimators=100, random_state=42, min_samples_leaf=2)
    model.fit(X_train, y_train)

    # Evaluamos el modelo (opcional, pero bueno para logging)
    preds = model.predict(X_test)
    rmse = np.sqrt(mean_squared_error(y_test, preds))
    print(f"Entrenamiento completado. RMSE en set de prueba: {rmse:.2f}")

    # Guardamos el modelo serializado
    model_path = os.path.join(settings.BASE_DIR, "ia", "sales_prediction_model.joblib")
    joblib.dump(model, model_path)
    print(f"Modelo guardado en: {model_path}")

    return model_path


def generate_predictions(days_to_predict=30):
    """
    Carga el modelo guardado y genera predicciones para los próximos N días.
    """
    model_path = os.path.join(settings.BASE_DIR, "ia", "sales_prediction_model.joblib")
    if not os.path.exists(model_path):
        return []

    model = joblib.load(model_path)
    future_dates = pd.date_range(start=pd.Timestamp.now().date(), periods=days_to_predict + 1)
    future_df = pd.DataFrame(index=future_dates)
    future_df = create_features(future_df)

    predictions = model.predict(future_df[['dia_semana', 'dia_mes', 'mes', 'anio', 'semana_anio']])
    
    return [{"fecha": date.strftime('%Y-%m-%d'), "prediccion": float(pred)} for date, pred in zip(future_dates, predictions)]

================================================================================
Archivo: ia/dataset
================================================================================

*** ERROR: Archivo no encontrado en la ruta: ia/dataset ***

================================================================================
Archivo: ia/models.py
================================================================================

from django.db import models

# Create your models here.


================================================================================
Archivo: ia/views.py
================================================================================

# analitica/views.py

from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import permissions

# Predicciones de ventas
from ia.train_predictions import generate_predictions

# Interpretación de comandos de voz
from ia.voice_intent import parse_voice_command


@api_view(["GET"])
@permission_classes([permissions.IsAuthenticated])
def sales_predictions_view(request):
    days = int(request.query_params.get("days", 30))
    data = generate_predictions(days_to_predict=days)
    return Response(data)


@api_view(["POST"])
@permission_classes([permissions.IsAuthenticated])
def voice_intent_view(request):
    """
    Recibe texto de voz y devuelve la intención detectada.

    body JSON:
    {
        "text": "agrega dos auriculares bt al carrito"
    }

    respuesta:
    {
        "raw": "...",
        "action": "add",
        "quantity": 2,
        "product_name": "auriculares bt"
    }
    """
    text = request.data.get("text", "") or ""
    intent = parse_voice_command(text)

    return Response(
        {
            "raw": intent.raw,
            "action": intent.action,
            "quantity": intent.quantity,
            "product_name": intent.product_name,
        }
    )


================================================================================
Archivo: ia/voice_intent.py
================================================================================

# ia/voice_intent.py

from __future__ import annotations

import re
from dataclasses import dataclass
from typing import Optional

from catalogo.models import Producto

SPANISH_NUMBERS = {
    "un": 1,
    "uno": 1,
    "una": 1,
    "dos": 2,
    "tres": 3,
    "cuatro": 4,
    "cinco": 5,
    "seis": 6,
    "siete": 7,
    "ocho": 8,
    "nueve": 9,
    "diez": 10,
}


@dataclass
class VoiceIntent:
    raw: str
    # add | remove | clear | checkout | unknown
    action: str
    quantity: int
    product_name: str


def _parse_quantity(text: str) -> int:
    text = text.lower()

    m = re.search(r"(\d+)", text)
    if m:
        try:
            n = int(m.group(1))
            if n > 0:
                return n
        except ValueError:
            pass

    for word, value in SPANISH_NUMBERS.items():
        if word in text:
            return value

    return 1


def _clean_product_name(text: str) -> str:
    text = text.lower()

    for r in [
        "al carrito",
        "del carrito",
        "a la cesta",
        "de la cesta",
        "por favor",
        "porfa",
    ]:
        text = text.replace(r, "")

    text = re.sub(r"\d+", " ", text)

    fillers = [
        "un",
        "una",
        "uno",
        "unos",
        "unas",
        "dos",
        "tres",
        "cuatro",
        "cinco",
        "seis",
        "siete",
        "ocho",
        "nueve",
        "diez",
    ]
    for f in fillers:
        text = re.sub(rf"\b{f}\b", " ", text)

    text = re.sub(r"\s+", " ", text).strip()
    return text


def parse_voice_command(text: str) -> VoiceIntent:
    raw = text
    text = (text or "").lower().strip()

    if not text:
        return VoiceIntent(raw=raw, action="unknown", quantity=0, product_name="")

    # 0) Finalizar compra / pagar / crear venta
    checkout_phrases = [
        "finalizar compra",
        "finaliza la compra",
        "terminar compra",
        "termina la compra",
        "quiero pagar",
        "pagar ahora",
        "realizar pago",
        "realiza el pago",
        "cobrar la compra",
        "cobra la compra",
        "cobrar",
        "crear venta",
        "crear la venta",
        "registrar venta",
        "registrar la venta",
        "finalizar la venta",
    ]
    if any(phrase in text for phrase in checkout_phrases):
        return VoiceIntent(raw=raw, action="checkout", quantity=0, product_name="")

    # 1) Vaciar carrito
    if (
        "vaciar carrito" in text
        or "limpiar carrito" in text
        or "borrar carrito" in text
        or "borra el carrito" in text
    ):
        return VoiceIntent(raw=raw, action="clear", quantity=0, product_name="")

    # 2) Quitar / remover / eliminar / sacar
    m = re.search(
        r"(quitar|quita|remover|remueve|eliminar|elimina|sacar|saca|borrar|borra)\s+(.*)",
        text,
    )
    if m:
        resto = (m.group(2) or "").strip()
        qty = _parse_quantity(resto)
        name = _clean_product_name(resto)
        return VoiceIntent(raw=raw, action="remove", quantity=qty, product_name=name)

    # 3) Agregar / sumar / poner
    m = re.search(
        r"(agrega|agregar|añade|añadir|suma|sumar|poner|pon)\s+(.*)",
        text,
    )
    if m:
        resto = (m.group(2) or "").strip()
        qty = _parse_quantity(resto)
        name = _clean_product_name(resto)
        return VoiceIntent(raw=raw, action="add", quantity=qty, product_name=name)

    # 4) Comprar / quiero / deseo / llevar
    m = re.search(
        r"(comprar|compra|quiero|deseo|llevar|llevo)\s+(.*)",
        text,
    )
    if m:
        resto = (m.group(2) or "").strip()
        qty = _parse_quantity(resto)
        name = _clean_product_name(resto)
        return VoiceIntent(raw=raw, action="add", quantity=qty, product_name=name)

    return VoiceIntent(raw=raw, action="unknown", quantity=1, product_name=text)


def _generate_variants(name: str) -> set[str]:
    name = name.strip().lower()
    variants = {name}
    if name.endswith("es") and len(name) > 2:
        variants.add(name[:-2])
    if name.endswith("s") and len(name) > 1:
        variants.add(name[:-1])
    return variants


def find_best_product(name_fragment: str) -> Optional[Producto]:
    if not name_fragment:
        return None

    name_fragment = name_fragment.lower().strip()
    qs = Producto.objects.filter(activo=True)

    # intento directo con variantes
    variants = _generate_variants(name_fragment)
    for v in variants:
        p = qs.filter(nombre__icontains=v).first()
        if p:
            return p

    # acortar frase desde el final
    parts = [p for p in name_fragment.split(" ") if p]
    while len(parts) > 1:
        parts.pop()
        shorter = " ".join(parts).strip()
        if not shorter:
            break
        variants = _generate_variants(shorter)
        for v in variants:
            p = qs.filter(nombre__icontains=v).first()
            if p:
                return p

    return None


================================================================================
Archivo: ia/urls.py
================================================================================

# analitica/urls.py

from django.urls import path
from .views import sales_predictions_view, voice_intent_view

urlpatterns = [
    path("predicciones/ventas/", sales_predictions_view, name="sales_predictions"),
    path("voz/intencion/", voice_intent_view, name="voice_intent"),
]


================================================================================
Archivo: analitica/views.py
================================================================================

# analitica/views.py

from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import permissions, status

# Predicciones de ventas
from ia.train_predictions import generate_predictions

# Interpretación de comandos de voz
from ia.voice_intent import parse_voice_command, find_best_product


@api_view(["GET"])
@permission_classes([permissions.IsAuthenticated])
def sales_predictions_view(request):
    days = int(request.query_params.get("days", 30))
    data = generate_predictions(days_to_predict=days)
    return Response(data)


@api_view(["POST"])
@permission_classes([permissions.IsAuthenticated])
def voice_intent_view(request):
    """
    Recibe texto de voz y devuelve la intención detectada y,
    si es posible, el producto correspondiente.

    body JSON:
    {
        "text": "agrega dos auriculares bt al carrito"
    }

    respuesta:
    {
        "raw": "...",
        "action": "add",
        "quantity": 2,
        "product_name": "auriculares bt",
        "product": {
            "id": 5,
            "nombre": "Auriculares BT",
            "precio": "40.00",
            "stock": 56
        }
    }
    """
    text = request.data.get("text", "") or ""
    intent = parse_voice_command(text)

    response_data = {
        "raw": intent.raw,
        "action": intent.action,
        "quantity": intent.quantity,
        "product_name": intent.product_name,
        "product": None,
    }

    if intent.action in ("add", "remove") and intent.product_name:
        product = find_best_product(intent.product_name)
        if product:
            response_data["product"] = {
                "id": product.id,
                "nombre": product.nombre,
                "precio": str(product.precio),
                "stock": product.stock,
            }

    return Response(response_data, status=status.HTTP_200_OK)


================================================================================
Archivo: analitica/urls.py
================================================================================

# analitica/urls.py

from django.urls import path
from .views import sales_predictions_view, voice_intent_view

urlpatterns = [
    path("predicciones/ventas/", sales_predictions_view, name="sales_predictions"),
    path("voz/intencion/", voice_intent_view, name="voice_intent"),
]


================================================================================
Archivo: frontend/src/pages/reportes/Reportes.jsx
================================================================================

// src/pages/Reportes.jsx
import { useState, useEffect, useRef } from 'react';
import api from '../../api/axios.js';
import { Mic, StopCircle, Download, Eye, Loader2, Info } from 'lucide-react';

const EXAMPLES = [
  {
    label: 'Ventas por cliente (mes actual)',
    text: 'Reporte de ventas de este mes agrupado por cliente en pantalla',
  },
  {
    label: 'Productos comprados por un cliente',
    text: 'Productos comprados por el cliente Juan Pérez del 01/11/2025 al 30/11/2025 agrupados por producto en pantalla',
  },
  {
    label: 'Top productos del mes',
    text: 'Top 10 productos más vendidos de este mes por monto en pantalla',
  },
  {
    label: 'Stock bajo (< 5 unidades)',
    text: 'Productos con stock menor a 5 unidades ordenados por stock ascendente en pantalla',
  },
  {
    label: 'Lista de precios por categoría',
    text: 'Lista de precios de productos de la categoría Electrodomésticos en pantalla',
  },
  {
    label: 'Productos sin movimiento',
    text: 'Productos sin movimiento de ventas en los últimos 3 meses en pantalla',
  },
];

export default function Reportes() {
  const [prompt, setPrompt] = useState('');
  const [isListening, setIsListening] = useState(false);
  const [supportsVoice, setSupportsVoice] = useState(true);

  const [isLoading, setIsLoading] = useState(false);
  const [loadingAction, setLoadingAction] = useState(null); // "preview" | "download" | null

  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [previewData, setPreviewData] = useState(null);

  const recRef = useRef(null);

  // -----------------------------
  // Configuración de voz
  // -----------------------------
  useEffect(() => {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) {
      setSupportsVoice(false);
      return;
    }

    const recognition = new SR();
    recognition.continuous = false;
    recognition.lang = 'es-ES';
    recognition.interimResults = false;

    recognition.onresult = async (evt) => {
      const t = evt.results?.[0]?.[0]?.transcript || '';
      setPrompt(t);

      // Auto-previsualizar en pantalla (quitamos "en pdf/excel")
      try {
        setIsLoading(true);
        setLoadingAction('preview');
        setError(null);
        setPreviewData(null);
        setSuccessMessage(null);

        const clean = t.replace(/\b(en\s+)?(pdf|excel|xlsx)\b/gi, '').trim();
        if (clean) {
          const r = await api.post('reportes/prompt/', { prompt: clean });
          setPreviewData(r.data);
        }
      } catch (err) {
        setError(
          err?.response?.data?.error ||
            err?.response?.data?.detail ||
            'No pude previsualizar el reporte.'
        );
      } finally {
        setIsLoading(false);
        setLoadingAction(null);
        setIsListening(false);
      }
    };

    recognition.onend = () => setIsListening(false);
    recognition.onerror = () => setIsListening(false);

    recRef.current = recognition;
  }, []);

  const handleListen = () => {
    if (!recRef.current) {
      alert('El reconocimiento de voz no es compatible con este navegador.');
      return;
    }
    setPreviewData(null);
    setError(null);
    setSuccessMessage(null);
    recRef.current.start();
    setIsListening(true);
  };

  const stopListen = () => {
    try {
      recRef.current?.stop();
    } catch (_) {}
    setIsListening(false);
  };

  // Limpieza automática de mensajes
  useEffect(() => {
    if (error || successMessage) {
      const timer = setTimeout(() => {
        setError(null);
        setSuccessMessage(null);
      }, 4500);
      return () => clearTimeout(timer);
    }
  }, [error, successMessage]);

  // -----------------------------
  // Acciones
  // -----------------------------
  const handlePreview = async (e) => {
    e?.preventDefault?.();
    if (!prompt.trim()) return;

    setIsLoading(true);
    setLoadingAction('preview');
    setError(null);
    setPreviewData(null);
    setSuccessMessage(null);

    try {
      // Para previsualizar siempre forzamos "en pantalla"
      const previewPrompt = prompt
        .replace(/\b(en\s+)?(pdf|excel|xlsx)\b/gi, '')
        .trim();
      const response = await api.post('reportes/prompt/', {
        prompt: previewPrompt,
      });
      setPreviewData(response.data);
    } catch (err) {
      setError(
        err.response?.data?.error ||
          err.response?.data?.detail ||
          'Ocurrió un error al previsualizar.'
      );
    } finally {
      setIsLoading(false);
      setLoadingAction(null);
    }
  };

  const handleDownload = async (e) => {
    e?.preventDefault?.();
    if (!prompt.trim()) return;

    if (!/pdf|excel|xlsx/i.test(prompt)) {
      setError("Para descargar, especifica 'en PDF' o 'en Excel' en el prompt.");
      return;
    }

    setIsLoading(true);
    setLoadingAction('download');
    setError(null);
    setPreviewData(null);
    setSuccessMessage(null);

    try {
      const response = await api.post(
        'reportes/prompt/',
        { prompt },
        { responseType: 'blob' }
      );

      const ext = /pdf/i.test(prompt) ? 'pdf' : 'xlsx';
      const filename = `reporte-${new Date().toISOString().slice(0, 10)}.${ext}`;

      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
      link.remove();
      window.URL.revokeObjectURL(url);

      setSuccessMessage(`¡Reporte "${filename}" descargado con éxito!`);
    } catch (err) {
      setError(
        err.response?.data?.detail ||
          err.response?.data?.error ||
          'Ocurrió un error al descargar el archivo.'
      );
    } finally {
      setIsLoading(false);
      setLoadingAction(null);
    }
  };

  // -----------------------------
  // Render
  // -----------------------------
  const headers = previewData?.headers || [];
  const rows = previewData?.rows || [];
  const meta = previewData?.meta || {};
  const hints = previewData?.hints || [];
  const warnings = previewData?.warnings || [];

  return (
    <div className="max-w-6xl mx-auto px-4 py-6 lg:py-8">
      {/* Encabezado */}
      <div className="mb-5 lg:mb-8">
        <h1 className="text-2xl lg:text-3xl font-semibold text-neutral-100 tracking-tight">
          Generador de reportes
        </h1>
        <p className="mt-2 text-sm lg:text-base text-neutral-400 max-w-2xl">
          Escribe o dicta lo que necesitas y el sistema generará el reporte
          consultando varias tablas (ventas, clientes, productos, stock, etc.).
        </p>
      </div>

      {/* Layout principal: prompt + preview */}
      <div className="grid gap-5 lg:gap-6 lg:grid-cols-[minmax(0,1.1fr)_minmax(0,1.2fr)]">
        {/* Panel de entrada */}
        <div className="bg-neutral-900/40 border border-neutral-800 rounded-2xl p-4 sm:p-5 shadow-lg flex flex-col h-full">
          <div className="flex items-center justify-between gap-2 mb-4">
            <h2 className="text-sm font-medium text-neutral-200 flex items-center gap-2">
              <Eye size={16} className="text-cyan-400" />
              Instrucción del reporte
            </h2>
            <span className="text-[11px] px-2 py-1 rounded-full bg-neutral-800/80 text-neutral-400">
              Ej: “Top 10 productos más vendidos de este mes en PDF”
            </span>
          </div>

          <div className="flex flex-col gap-2">
            <div className="flex flex-col sm:flex-row gap-2">
              <textarea
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder="Describe el reporte que quieres generar..."
                disabled={isLoading && loadingAction === 'download'}
                rows={4}
                className="flex-1 min-h-[120px] rounded-xl bg-neutral-950 border border-neutral-800 focus:border-cyan-500/50 focus:ring-2 focus:ring-cyan-500/20 text-neutral-200 text-sm p-3 outline-none placeholder:text-neutral-500 resize-none"
              />

              {/* Botón de voz */}
              {supportsVoice && (
                <button
                  type="button"
                  onClick={isListening ? stopListen : handleListen}
                  disabled={isLoading}
                  className={`flex-shrink-0 h-11 w-full sm:w-12 sm:h-[46px] rounded-xl border text-sm sm:text-base grid place-items-center transition
                    ${
                      isListening
                        ? 'border-red-500/60 bg-red-600/20 text-red-200'
                        : 'border-neutral-700 bg-neutral-950 hover:bg-neutral-900 text-neutral-200'
                    }
                    ${isLoading ? 'opacity-60 cursor-not-allowed' : ''}
                  `}
                >
                  {isListening ? <StopCircle size={18} /> : <Mic size={18} />}
                </button>
              )}
            </div>

            {/* Chips de ejemplos */}
            <div className="mt-2 flex flex-wrap gap-2">
              {EXAMPLES.map((ex) => (
                <button
                  key={ex.label}
                  type="button"
                  onClick={() => setPrompt(ex.text)}
                  className="text-[11px] sm:text-xs px-2.5 py-1 rounded-full border border-neutral-700/80 text-neutral-300 bg-neutral-950/60 hover:bg-neutral-900/90 transition"
                >
                  {ex.label}
                </button>
              ))}
            </div>
          </div>

          {/* Botones de acción */}
          <div className="mt-4 flex flex-col sm:flex-row gap-2">
            <button
              type="button"
              onClick={handlePreview}
              disabled={isLoading && loadingAction === 'download' || !prompt.trim()}
              className="inline-flex justify-center items-center gap-2 px-4 py-2 rounded-xl border border-neutral-700 bg-neutral-950 hover:bg-neutral-900 text-neutral-100 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isLoading && loadingAction === 'preview' ? (
                <Loader2 className="animate-spin" size={18} />
              ) : (
                <Eye size={18} />
              )}
              <span>Previsualizar</span>
            </button>

            <button
              type="button"
              onClick={handleDownload}
              disabled={isLoading && loadingAction === 'preview' || !prompt.trim()}
              className="inline-flex justify-center items-center gap-2 px-4 py-2 rounded-xl bg-cyan-500 text-neutral-900 font-medium text-sm hover:bg-cyan-400 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isLoading && loadingAction === 'download' ? (
                <Loader2 className="animate-spin" size={18} />
              ) : (
                <Download size={18} />
              )}
              <span>Descargar</span>
            </button>
          </div>

          {/* Mensajes de estado */}
          {error && (
            <div className="mt-4 text-xs sm:text-sm text-red-300 bg-red-600/10 border border-red-900/40 rounded-xl p-3">
              {error}
            </div>
          )}
          {successMessage && (
            <div className="mt-4 text-xs sm:text-sm text-emerald-300 bg-emerald-600/10 border border-emerald-900/40 rounded-xl p-3">
              {successMessage}
            </div>
          )}

          {/* Tips rápidos */}
          <div className="mt-4 text-[11px] sm:text-xs text-neutral-400 flex items-start gap-2">
            <Info size={14} className="mt-0.5 flex-shrink-0 text-neutral-500" />
            <div>
              <div>
                Para descargar, incluye al final <span className="font-semibold">'en PDF'</span> o{' '}
                <span className="font-semibold">'en Excel'</span>.
              </div>
              <div>
                Si no indicas rango de fechas, el sistema usa los últimos 30 días.
              </div>
            </div>
          </div>
        </div>

        {/* Panel de previsualización */}
        <div className="bg-neutral-900/40 border border-neutral-800 rounded-2xl p-4 sm:p-5 shadow-lg flex flex-col h-full">
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-sm font-medium text-neutral-200">
              Previsualización
            </h3>
            <span className="text-[11px] text-neutral-500">
              Solo se muestra al usar “Previsualizar”
            </span>
          </div>

          {/* Meta del reporte */}
          {previewData ? (
            <>
              <div className="mb-3 flex flex-wrap gap-2 text-[11px] text-neutral-400">
                {meta?.intent && (
                  <span className="px-2 py-1 rounded-full bg-neutral-950/80 border border-neutral-800">
                    Intento: <span className="font-semibold">{meta.intent}</span>
                  </span>
                )}
                {meta?.start_date && meta?.end_date && (
                  <span className="px-2 py-1 rounded-full bg-neutral-950/80 border border-neutral-800">
                    Rango: {meta.start_date} — {meta.end_date}
                  </span>
                )}
                {meta?.dimensions && (
                  <span className="px-2 py-1 rounded-full bg-neutral-950/80 border border-neutral-800">
                    Grupo: {Array.isArray(meta.dimensions) ? meta.dimensions.join(', ') : meta.dimensions}
                  </span>
                )}
              </div>

              {(hints.length > 0 || warnings.length > 0) && (
                <div className="mb-3 space-y-1 text-[11px] text-neutral-400">
                  {hints.map((h, i) => (
                    <div key={`hint-${i}`} className="flex gap-1">
                      <span className="mt-[2px] text-cyan-400">•</span>
                      <span>{h}</span>
                    </div>
                  ))}
                  {warnings.map((w, i) => (
                    <div key={`warn-${i}`} className="flex gap-1 text-amber-300">
                      <span className="mt-[2px]">•</span>
                      <span>{w}</span>
                    </div>
                  ))}
                </div>
              )}

              {/* Tabla */}
              <div className="relative flex-1 min-h-[180px] border border-neutral-800/70 rounded-xl bg-neutral-950/80 overflow-hidden">
                <div className="overflow-x-auto max-h-[420px]">
                  <table className="min-w-full text-[11px] sm:text-xs">
                    <thead className="bg-neutral-950 sticky top-0 z-10">
                      <tr className="text-neutral-400">
                        {headers.length > 0 ? (
                          headers.map((h) => (
                            <th
                              key={h}
                              className="text-left px-3 py-2 border-b border-neutral-800"
                            >
                              {h}
                            </th>
                          ))
                        ) : (
                          <th className="px-3 py-2 border-b border-neutral-800">
                            Resultado
                          </th>
                        )}
                      </tr>
                    </thead>
                    <tbody>
                      {rows.length > 0 ? (
                        rows.map((row, i) => (
                          <tr
                            key={i}
                            className={i % 2 === 0 ? 'bg-neutral-900/40' : ''}
                          >
                            {row.map((cell, j) => {
                              const header = headers[j] || '';
                              const alignRight = /monto|total|precio|cantidad/i.test(
                                header
                              );
                              return (
                                <td
                                  key={j}
                                  className={`px-3 py-2 whitespace-nowrap ${
                                    alignRight ? 'text-right' : ''
                                  }`}
                                >
                                  {cell}
                                </td>
                              );
                            })}
                          </tr>
                        ))
                      ) : (
                        <tr>
                          <td
                            className="px-3 py-6 text-neutral-400 text-center"
                            colSpan={headers.length || 1}
                          >
                            No se encontraron resultados para este reporte.
                          </td>
                        </tr>
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            </>
          ) : (
            <div className="flex-1 flex items-center justify-center text-center text-neutral-500 text-xs sm:text-sm border border-dashed border-neutral-800 rounded-xl bg-neutral-950/40 px-4 py-8">
              Escribe una instrucción y haz clic en{' '}
              <span className="mx-1 font-semibold text-neutral-300">
                “Previsualizar”
              </span>{' '}
              para ver el resultado aquí.
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


================================================================================
Archivo: frontend/src/pages/Dashboard.jsx
================================================================================

import { useEffect, useState } from 'react'
import { Link } from 'react-router-dom'
import api from '../api/axios.js'
import { ResponsiveContainer, ComposedChart, CartesianGrid, XAxis, YAxis, Tooltip, Bar, Line, PieChart, Pie, Cell, Legend } from 'recharts'
import { DollarSign, ShoppingCart, UserPlus, Ticket } from 'lucide-react'

const COLORS = ['#0ea5e9', '#6366f1', '#ec4899', '#f97316', '#10b981'];

function KpiCard({ title, value, icon, prefix = '' }) {
  return (
    <div className="card">
      <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
        <div style={{ padding: '12px', background: 'var(--border)', borderRadius: '50%' }}>
          {icon}
        </div>
        <div>
          <div style={{ color: 'var(--muted)' }}>{title}</div>
          <div style={{ fontSize: '24px', fontWeight: 700 }}>{prefix}{value}</div>
        </div>
      </div>
    </div>
  );
}

export default function Dashboard(){
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [predictions, setPredictions] = useState([]);

  useEffect(()=>{
    const fetchData = async()=>{
      try{
        // Pedimos los datos históricos y las predicciones en paralelo
        const [dashboardRes, predictionsRes] = await Promise.all([
          api.get('/reportes/dashboard/'),
          api.get('/analitica/predicciones/ventas/')
        ]);
        setData(dashboardRes.data);
        setPredictions(predictionsRes.data);
      } catch(error) {
        console.error("Error al cargar los datos del dashboard", error);
      } finally {
        setLoading(false);
      }
    }
    fetchData()
  },[])

  // Combinamos datos históricos y de predicción para el gráfico principal
  const combinedChartData = (data?.ventas_ultimos_30_dias || []).map(item => ({
    ...item,
    type: 'historico'
  })).concat(predictions.map(pred => ({
    fecha: pred.fecha,
    total: pred.prediccion,
    type: 'prediccion'
  })));

  if (loading) return <div className="card">Cargando dashboard...</div>;
  if (!data) return <div className="card">No se pudieron cargar los datos del dashboard.</div>;

  return (
    <div className="grid">
      {/* Fila de KPIs */}
      <div className="grid grid-kpi">
        <KpiCard title="Ventas de Hoy" value={data.kpis.ventas_hoy} prefix="Bs. " icon={<DollarSign />} />
        <KpiCard title="Ventas del Mes" value={data.kpis.ventas_mes_actual} prefix="Bs. " icon={<ShoppingCart />} />
        <KpiCard title="Nuevos Clientes (Mes)" value={data.kpis.nuevos_clientes_mes} icon={<UserPlus />} />
        <KpiCard title="Ticket Promedio (Mes)" value={data.kpis.ticket_promedio} prefix="Bs. " icon={<Ticket />} />
      </div>

      {/* Fila de Gráficos */}
      <div className="grid grid-2">
        <div className="card">
          <h3>Ventas y Predicciones (Próximos 30 días)</h3>
          <div style={{width:'100%', height:280}}>
            <ResponsiveContainer width="100%" height="100%">
              <ComposedChart data={combinedChartData}>
                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                <XAxis dataKey="fecha" tickFormatter={(date) => new Date(date).toLocaleDateString('es-BO', { day: '2-digit', month: '2-digit' })} />
                <YAxis />
                <Tooltip formatter={(value) => `Bs. ${value.toLocaleString()}`} />
                <Legend />
                <Bar dataKey="total" name="Venta Histórica" fill="var(--brand)" />
                <Line type="monotone" dataKey="total" name="Predicción" stroke="#ec4899" strokeDasharray="5 5" dot={false} />
              </ComposedChart>
            </ResponsiveContainer>
          </div>
        </div>
        <div className="card">
          <h3>Ventas por Categoría (Mes)</h3>
          <div style={{width:'100%', height:280}}>
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie data={data.ventas_por_categoria} dataKey="total" nameKey="categoria" cx="50%" cy="50%" outerRadius={80} label>
                  {data.ventas_por_categoria.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip formatter={(value) => `Bs. ${value.toLocaleString()}`} />
                <Legend />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>

      {/* Fila de Últimas Ventas */}
      <div className="card">
        <h3>Últimas Ventas</h3>
        <div className="table-responsive">
          <table className="table-nowrap">
            <thead><tr><th>Folio</th><th>Cliente</th><th>Total</th><th>Fecha</th><th></th></tr></thead>
            <tbody>
              {data.ultimas_ventas.map(v => (
                <tr key={v.id}>
                  <td>{v.folio}</td>
                  <td>{v.cliente}</td>
                  <td>Bs. {v.total}</td>
                  <td>{v.fecha}</td>
                  <td><Link to={`/ventas/${v.id}`}>Ver Detalle</Link></td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
      {/* Estilo para el grid de KPIs */}
      <style>{`.grid-kpi { grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }`}</style>
    </div>
  )
}


